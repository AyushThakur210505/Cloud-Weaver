import { stringify as yamlStringify } from "yaml";
import { Diagnostic } from "./deps";
import { InfraGraphV1, InfraNode } from "./infraGraph";

type LogicalId = string;

interface EmitResult {
  ok: boolean;
  diagnostics: Diagnostic[];
  templateYAML?: string;
  orderedNodeIds?: string[];
}

export function emitCloudFormationTemplate(
  graph: InfraGraphV1,
  orderedNodeIds: string[],
  depEdges: Array<{ from: string; to: string }>
): EmitResult {
  const diagnostics: Diagnostic[] = [];

  const nodeById = new Map<string, InfraNode>();
  graph.nodes.forEach((n) => nodeById.set(n.id, n));

  const logicalIdByNodeId = new Map<string, LogicalId>();
  for (const node of graph.nodes) {
    logicalIdByNodeId.set(node.id, toLogicalId(node));
  }

  const resources: Record<string, any> = {};
  const parameters: Record<string, any> = buildParameters(graph);

  // Emit primary resources in dependency order
  for (const nodeId of orderedNodeIds) {
    const node = nodeById.get(nodeId);
    if (!node) continue;

    const logicalId = logicalIdByNodeId.get(nodeId)!;

    try {
      const resource = buildResource(node, graph, logicalIdByNodeId, depEdges);
      if (resource) resources[logicalId] = resource;
    } catch (err: any) {
      diagnostics.push({
        level: "error",
        message: `Failed to build resource for node '${node.name}': ${err?.message ?? String(err)}`,
        nodeIds: [nodeId],
      });
    }
  }

  // Emit IGW attachments when graph expresses VPC <-> IGW attachment.
  for (const e of graph.edges) {
    if (e.kind !== "attaches") continue;
    const src = nodeById.get(e.source);
    const tgt = nodeById.get(e.target);
    if (!src || !tgt) continue;
    if (src.type !== "vpc" || tgt.type !== "igw") continue;

    const vpcLogicalId = logicalIdByNodeId.get(src.id);
    const igwLogicalId = logicalIdByNodeId.get(tgt.id);
    if (!vpcLogicalId || !igwLogicalId) continue;

    const attachmentLogicalId = `VPCGatewayAttachment${vpcLogicalId}${igwLogicalId}`;
    resources[attachmentLogicalId] = {
      Type: "AWS::EC2::VPCGatewayAttachment",
      Properties: {
        VpcId: { Ref: vpcLogicalId },
        InternetGatewayId: { Ref: igwLogicalId },
      },
      DependsOn: [vpcLogicalId, igwLogicalId],
    };
  }

  const template: any = {
    AWSTemplateFormatVersion: "2010-09-09",
    Description: "Generated by CloudWeaver",
    Parameters: Object.keys(parameters).length ? parameters : undefined,
    Resources: resources,
  };

  const templateYAML = yamlStringify(template);
  const ok = !diagnostics.some((d) => d.level === "error");

  return { ok, diagnostics, templateYAML, orderedNodeIds };
}

function toLogicalId(node: InfraNode): LogicalId {
  const base = node.name || `${node.type}-${node.id}`;
  const pascal = base
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .filter(Boolean)
    .map((w) => w[0].toUpperCase() + w.slice(1))
    .join("");

  const typePrefixMap: Record<string, string> = {
    vpc: "VPC",
    subnet: "Subnet",
    igw: "IGW",
    security_group: "SecurityGroup",
    ec2_instance: "Instance",
  };
  const prefix = typePrefixMap[node.type] ?? "";
  return prefix + pascal;
}

function buildParameters(graph: InfraGraphV1): Record<string, any> {
  const params: Record<string, any> = {};
  if (!graph.variables) return params;

  for (const [name, v] of Object.entries(graph.variables)) {
    const typeMap: Record<string, string> = {
      string: "String",
      number: "Number",
      bool: "String", // CloudFormation typically models bool as String ("true"/"false")
    };

    params[name] = {
      Type: typeMap[v.type],
      Default: v.default,
      Description: v.description,
    };
  }

  return params;
}

function refOrLiteral(value: any): any {
  if (typeof value === "string" && value.startsWith("${") && value.endsWith("}")) {
    const varName = value.slice(2, -1);
    return { Ref: varName };
  }
  return value;
}

function buildResource(
  node: InfraNode,
  graph: InfraGraphV1,
  logicalIdByNodeId: Map<string, LogicalId>,
  depEdges: Array<{ from: string; to: string }>
): any {
  const dependsOnLogicalIds = depEdges
    .filter((e) => e.to === node.id)
    .map((e) => logicalIdByNodeId.get(e.from)!)
    .filter(Boolean);

  const base: any = {};
  if (dependsOnLogicalIds.length === 1) base.DependsOn = dependsOnLogicalIds[0];
  else if (dependsOnLogicalIds.length > 1) base.DependsOn = dependsOnLogicalIds;

  switch (node.type) {
    case "vpc":
      return {
        ...base,
        Type: "AWS::EC2::VPC",
        Properties: {
          CidrBlock: refOrLiteral(node.config.cidrBlock),
          EnableDnsSupport: node.config.enableDnsSupport ?? true,
          EnableDnsHostnames: node.config.enableDnsHostnames ?? true,
          Tags: [{ Key: "Name", Value: node.name }],
        },
      };

    case "subnet": {
      const vpcLogicalId = resolveVpcLogicalIdForSubnet(node, graph, logicalIdByNodeId);
      return {
        ...base,
        Type: "AWS::EC2::Subnet",
        Properties: {
          VpcId: { Ref: vpcLogicalId },
          CidrBlock: refOrLiteral(node.config.cidrBlock),
          AvailabilityZone: node.config.az,
          MapPublicIpOnLaunch: node.config.mapPublicIpOnLaunch ?? true,
          Tags: [{ Key: "Name", Value: node.name }],
        },
      };
    }

    case "igw":
      return {
        ...base,
        Type: "AWS::EC2::InternetGateway",
        Properties: {
          Tags: [{ Key: "Name", Value: node.name }],
        },
      };

    case "security_group": {
      const vpcLogicalId = resolveVpcLogicalIdForSecurityGroup(node, graph, logicalIdByNodeId);
      return {
        ...base,
        Type: "AWS::EC2::SecurityGroup",
        Properties: {
          GroupDescription: node.config.description || node.name || "Security group",
          VpcId: { Ref: vpcLogicalId },
          SecurityGroupIngress: (node.config.ingress ?? []).map((r: any) => ({
            IpProtocol: r.protocol,
            FromPort: r.fromPort,
            ToPort: r.toPort,
            CidrIp: r.cidr ?? "0.0.0.0/0",
          })),
          SecurityGroupEgress: (node.config.egress ?? []).map((r: any) => ({
            IpProtocol: r.protocol,
            FromPort: r.fromPort,
            ToPort: r.toPort,
            CidrIp: r.cidr ?? "0.0.0.0/0",
          })),
        },
      };
    }

    case "ec2_instance": {
      const { subnetLogicalId, securityGroupLogicalIds } = resolveNetworkingForInstance(
        node,
        graph,
        logicalIdByNodeId
      );

      return {
        ...base,
        Type: "AWS::EC2::Instance",
        Properties: {
          ImageId: refOrLiteral(node.config.ami),
          InstanceType: refOrLiteral(node.config.instanceType),
          KeyName: node.config.keyName ? refOrLiteral(node.config.keyName) : undefined,
          NetworkInterfaces: [
            {
              AssociatePublicIpAddress: true,
              DeviceIndex: "0",
              SubnetId: { Ref: subnetLogicalId },
              GroupSet: securityGroupLogicalIds.map((id) => ({ Ref: id })),
            },
          ],
          UserData: node.config.userDataBase64,
          Tags: [{ Key: "Name", Value: node.name }],
        },
      };
    }

    default:
      return undefined;
  }
}

function resolveVpcLogicalIdForSubnet(
  subnet: InfraNode,
  graph: InfraGraphV1,
  logicalIdByNodeId: Map<string, LogicalId>
): LogicalId {
  const explicitRef = subnet.refs?.vpcId;
  if (explicitRef) {
    const logical = logicalIdByNodeId.get(explicitRef);
    if (logical) return logical;
  }
  const vpcs = graph.nodes.filter((n) => n.type === "vpc");
  return logicalIdByNodeId.get(vpcs[0]?.id)!;
}

function resolveVpcLogicalIdForSecurityGroup(
  sg: InfraNode,
  graph: InfraGraphV1,
  logicalIdByNodeId: Map<string, LogicalId>
): LogicalId {
  const explicitRef = sg.refs?.vpcId;
  if (explicitRef) {
    const logical = logicalIdByNodeId.get(explicitRef);
    if (logical) return logical;
  }
  const vpcs = graph.nodes.filter((n) => n.type === "vpc");
  return logicalIdByNodeId.get(vpcs[0]?.id)!;
}

function resolveNetworkingForInstance(
  instance: InfraNode,
  graph: InfraGraphV1,
  logicalIdByNodeId: Map<string, LogicalId>
): { subnetLogicalId: LogicalId; securityGroupLogicalIds: LogicalId[] } {
  const subnetLogicalId = (() => {
    const explicit = instance.refs?.subnetId;
    if (explicit) {
      const logical = logicalIdByNodeId.get(explicit);
      if (logical) return logical;
    }
    const subnets = graph.nodes.filter((n) => n.type === "subnet");
    return logicalIdByNodeId.get(subnets[0]?.id)!;
  })();

  const sgLogicalIds: LogicalId[] = [];
  if (instance.refs?.securityGroupIds?.length) {
    for (const id of instance.refs.securityGroupIds) {
      const logical = logicalIdByNodeId.get(id);
      if (logical) sgLogicalIds.push(logical);
    }
  } else {
    const sgs = graph.nodes.filter((n) => n.type === "security_group");
    if (sgs[0]) {
      const logical = logicalIdByNodeId.get(sgs[0].id);
      if (logical) sgLogicalIds.push(logical);
    }
  }

  return { subnetLogicalId, securityGroupLogicalIds: sgLogicalIds };
}

